#include  "wendu18b20.h"
#include  "lcd.h"
#define	uchar unsigned char
#define	uint unsigned int	// 这些宏定义都可以在头文件 .h 里定义
uchar dis3[] = "temp:";
sbit ds=P2^7;     				 //温度传感器信号线
uint temp;
float f_temp;
/*******************************************************************/
/*                                                                 */
/* 18B20复位，初始化函数函数                                       */
/*                                                                 */
/*******************************************************************/
void dsreset(void)   
{
  uint i;
  ds=0;
  i=103;
  while(i>0)i--;//提供480-950us延时
  ds=1;
  i=4; 
  while(i>0)i--;//提供60-240us的延时；单片机检测到低电平复位成功
}
/*******************************************************************/
/*                                                                 */
/* 18B20读1位数据函数                                              */
/*                                                                 */
/*******************************************************************/
bit tempreadbit(void)  
{
   uint i;
   bit dat;
   ds=0;i++;          //i++ 起延时作用
   ds=1;i++;i++;
   dat=ds;           //ds为低电平则读0反之则为1
   i=8;while(i>0)i--;   //提供延时
   return (dat);
}
/*******************************************************************/
/*                                                                 */
/* 18B20读1字节数据函数                                              */
/*                                                                 */
/*******************************************************************/
uchar tempread(void)   
{
  uchar i,j,dat;
  dat=0;
  for(i=1;i<=8;i++)
  {
    j=tempreadbit();
    dat=(j<<7)|(dat>>1);   //读出的数据最低位在最前面，这样刚好一个字节在DAT里
  }
  return(dat);
}
/*******************************************************************/
/*                                                                 */
/* 18B20写1字节数据函数                                              */
/*                                                                 */
/*******************************************************************/
void tempwritebyte(uchar dat)  
{
  uint i;
  uchar j;
  bit testb;
  for(j=1;j<=8;j++)
  {
    testb=dat&0x01;
    dat=dat>>1;
    if(testb)     //写 1
    {
      ds=0;
      i++;i++;
      ds=1;
      i=8;
      while(i>0)i--;
    }
    else
    {
      ds=0;       //写 0
      i=8;while(i>0)i--;
      ds=1;
      i++;i++;
    }

  }
}
/*******************************************************************/
/*                                                                 */
/* 18B20开始获取温度并转换                                         */
/*                                                                 */
/*******************************************************************/
void tempchange(void) {
  dsreset();
  delay(1);
  tempwritebyte(0xcc);  // 写跳过读ROM指令
  tempwritebyte(0x44);  // 写温度转换指令
}
/*******************************************************************/
/*                                                                 */
/* 18B20读取寄存器中存储的温度数据                                 */
/*                                                                 */
/*******************************************************************/
uint get_temp()        
{
  uchar a,b;
  dsreset();
  delay(1);
  tempwritebyte(0xcc);
  tempwritebyte(0xbe);  //读取RAM
  a=tempread();         //读低8位
  b=tempread();         //读高8位
  temp=b;
  temp<<=8;            //两个字节组合为1个字
  temp=temp|a;
  f_temp=temp*0.0625;      //温度在寄存器中为12位 分辨率位0.0625°
  temp=f_temp*10+0.5;    //乘以10表示小数点后面只取1位，加0.5是四舍五入
  f_temp=f_temp+0.05; 
  return temp;         //temp是整型
}
/*******************************************************************/
/*                                                                 */
/* 				18B20温度显示                                      */
/*                                                                 */
/*******************************************************************/
void tempdisplay()					  //
{
uchar i;
 uint mm;
 tempchange();
mm=get_temp(); 
dis3[5]=mm%1000/100+'0';
dis3[6]=mm%100/10+'0';
dis3[7]='.';
dis3[8]=mm%10+'0';

write_com(0x80+0x40); 

// uchar t;
for(i=0;i<9;i++)
	{
		write_date(dis3[i]);
		delay(10);
	}
//搞完复位
//lcd_wcmd(0x01);
//delay1(10);	
}